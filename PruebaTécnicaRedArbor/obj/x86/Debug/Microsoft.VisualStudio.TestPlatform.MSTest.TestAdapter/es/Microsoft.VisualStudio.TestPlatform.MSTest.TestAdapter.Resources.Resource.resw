<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="UTA_AssemblyCleanupMethodWasUnsuccesful" xml:space="preserve">
    <value>Error de método Cleanup de ensamblado {0}.{1}. Mensaje de error: {2}. StackTrace: {3}</value>
  </data>
  <data name="CouldNotInspectTypeDuringDiscovery1" xml:space="preserve">
    <value>MSTestAdapter no detectó pruebas en la clase '{0}' del ensamblado '{1}'. Motivo: {2}.</value>
  </data>
  <data name="Common_CannotBeNullOrEmpty" xml:space="preserve">
    <value>El parámetro no debe ser NULL ni estar vacío.</value>
  </data>
  <data name="Execution_Test_Cancelled" xml:space="preserve">
    <value>Se anuló la ejecución de la prueba "{0}".</value>
  </data>
  <data name="DiscoveryWarning" xml:space="preserve">
    <value>[MSTest][Discovery][{0}] {1}</value>
  </data>
  <data name="InvalidSettingsXmlElement" xml:space="preserve">
    <value>Valor no válido '{0}'. XmlElement no esperado: '{1}'.</value>
  </data>
  <data name="TestContextMessageBanner" xml:space="preserve">
    <value>Mensajes de TestContext:</value>
  </data>
  <data name="UTA_TestInitializeAndCleanupMethodHasWrongSignature" xml:space="preserve">
    <value>Método {0}.{1} tiene firma incorrecta. Debe ser un método no estático, público, no devolver ningún valor y no debe aceptar parámetros. Además, si está usando async-await en el método, el tipo devuelto debe ser Task.</value>
  </data>
  <data name="UTA_ClassOrAssemblyInitializeMethodHasWrongSignature" xml:space="preserve">
    <value>Método {0}.{1} tiene firma incorrecta. El método debe ser estático y público, no devolver ningún valor y debe aceptar un solo parámetro tipo TestContext. Además, si está usando async-await en el método, el tipo devuelto debe ser Task.</value>
  </data>
  <data name="InvalidSettingsXmlAttribute" xml:space="preserve">
    <value>Valor no válido '{0}'. XmlAttribute no esperado: '{1}'.</value>
  </data>
  <data name="UTA_ErrorMultiAssemblyInit" xml:space="preserve">
    <value>UTA013: {0}: No se puede definir más de un método con el atributo AssemblyInitialize dentro de un ensamblado.</value>
  </data>
  <data name="UTA_ErrorMultiClassInit" xml:space="preserve">
    <value>UTA025: {0}: No se puede definir más de un método con el atributo ClassInitialize dentro de una clase.</value>
  </data>
  <data name="UTA_ExpectedExceptionAttributeConstructionException" xml:space="preserve">
    <value>El atributo ExpectedException definido en el método de prueba {0}.{1} inició una excepción durante la construcción.
{2}</value>
  </data>
  <data name="UTA_ErrorPredefinedTestProperty" xml:space="preserve">
    <value>UTA023: {0}: no se puede definir la propiedad predefinida {2} en el método {1}.</value>
  </data>
  <data name="UTA_InitMethodThrows" xml:space="preserve">
    <value>El método de inicialización {0}.{1} devolvió una excepción. {2}.</value>
  </data>
  <data name="TestNotFound" xml:space="preserve">
    <value>No encontrado método prueba {0}.</value>
  </data>
  <data name="Execution_Test_Timeout" xml:space="preserve">
    <value>La prueba '{0}' superó el tiempo de espera de ejecución.</value>
  </data>
  <data name="UTA_ErrorMultiInit" xml:space="preserve">
    <value>UTA018: {0}: No se puede definir más de un método con el atributo TestInitialize.</value>
  </data>
  <data name="TestAssembly_AssemblyDiscoveryFailure" xml:space="preserve">
    <value>No se pudieron detectar pruebas desde el ensamblado {0}. Motivo:{1}</value>
  </data>
  <data name="UTA_ErrorNonPublicTestClass" xml:space="preserve">
    <value>UTA001: se ha definido el atributo TestClass en la clase no pública {0}</value>
  </data>
  <data name="UTA_ErrorIncorrectTestMethodSignature" xml:space="preserve">
    <value>UTA007: El método {1} definido en la clase {0} no tiene una signatura correcta. El método de prueba marcado con el atributo [TestMethod] debe ser no estático, público, con el tipo devuelto void y no debe tomar ningún parámetro. Ejemplo: public void Test.Class1.Test(). Además, si está usando async-await en el método de prueba, el tipo devuelto debe ser Task. Ejemplo: public async Task Test.Class1.Test2()</value>
  </data>
  <data name="UTA_ErrorTestPropertyNullOrEmpty" xml:space="preserve">
    <value>UTA021: {0}: se ha definido una propiedad personalizada nula o vacía en el método {1}. La propiedad personalizada debe tener un nombre válido.</value>
  </data>
  <data name="UTA_NoTestResult" xml:space="preserve">
    <value>No se pudo ejecutar prueba. Extensión no devolvió resultados. Si usa extensión TestMethodAttribute, contacte con el proveedor.</value>
  </data>
  <data name="UTA_ClassCleanupMethodWasUnsuccesful" xml:space="preserve">
    <value>Error de método Cleanup de clase {0}.{1}. Mensaje error: {2}. Seguimiento de pila: {3}</value>
  </data>
  <data name="UTA_ErrorTestPropertyAlreadyDefined" xml:space="preserve">
    <value>UTA022: {0}.{1}: ya definida propiedad personalizada "{2}". Usando "{3}" como valor.</value>
  </data>
  <data name="SourcesNotSupported" xml:space="preserve">
    <value>La ejecución de pruebas en las fuentes proporcionadas no se admite para la plataforma seleccionada</value>
  </data>
  <data name="UTA_ClassInitMethodThrows" xml:space="preserve">
    <value>Excepción del método inicialización clase {0}. {1}. {2}: {3}.</value>
  </data>
  <data name="TestContextIsNull" xml:space="preserve">
    <value>TestContext no será null.</value>
  </data>
  <data name="DataDrivenResultDisplayName" xml:space="preserve">
    <value>{0} (Fila de datos {1})</value>
  </data>
  <data name="UTA_WrongThread" xml:space="preserve">
    <value>{0}. En proyectos de UWP, si usa objetos de interfaz de usuario en la prueba, podría usar el atributo [UITestMethod] en lugar de [TestMethod] para ejecutar la prueba en el subproceso de interfaz de usuario.</value>
  </data>
  <data name="UTA_ExecuteThrewException" xml:space="preserve">
    <value>Se inició una excepción al ejecutar la prueba. Si usa la extensión de TestMethodAttribute, póngase en contacto con el proveedor. Mensaje de error: {0}</value>
  </data>
  <data name="UTA_TestMethodThrows" xml:space="preserve">
    <value>Excepción método de prueba {0}.{1}: 
{2}</value>
  </data>
  <data name="UTA_CleanupMethodThrows" xml:space="preserve">
    <value>El método TestCleanup {0}.{1} devolvió una excepción. {2}: {3}.</value>
  </data>
  <data name="UTA_InstanceCreationError" xml:space="preserve">
    <value>No se puede crear una instancia de la clase {0}. Error: {1}.</value>
  </data>
  <data name="TestParallelizationBanner" xml:space="preserve">
    <value>Ejecutor de MSTest Executor: paralelización de prueba habilitada para {0} (Trabajadores: {1}, Ámbito: {2}).</value>
  </data>
  <data name="UTA_TestContextTypeMismatchLoadError" xml:space="preserve">
    <value>Tipo {0}.TestContext no es correcto.</value>
  </data>
  <data name="DebugTraceBanner" xml:space="preserve">
    <value>Seguimiento de depuración:</value>
  </data>
  <data name="UTA_ClassOrAssemblyCleanupMethodHasWrongSignature" xml:space="preserve">
    <value>Método {0}.{1} tiene firma incorrecta. El método debe ser estático, público, no devolver un valor y no aceptar ningún parámetro. Además, si usa async-esperan en método de tipo de valor devuelto debe ser una tarea.</value>
  </data>
  <data name="UTA_ErrorGenericTestMethod" xml:space="preserve">
    <value>UTA015: Un método genérico no puede ser un método de prueba. {0}.{1} tiene una firma no válida</value>
  </data>
  <data name="UTA_AssemblyInitMethodThrows" xml:space="preserve">
    <value>Excepción método inicialización ensamblado {0}.{1}. {2}: {3}. Anulada ejecución de prueba.</value>
  </data>
  <data name="UTA_ErrorMultiClean" xml:space="preserve">
    <value>UTA024: {0}: No se puede definir más de un método con el atributo TestCleanup.</value>
  </data>
  <data name="InvalidParallelScopeValue" xml:space="preserve">
    <value>Valor no válido "{0}" especificado para "Ámbito". Los ámbitos admitidos son {1}.</value>
  </data>
  <data name="UTF_FailedToGetExceptionMessage" xml:space="preserve">
    <value>(No se pudo obtener el mensaje para una excepción del tipo {0} debido a una excepción.)</value>
  </data>
  <data name="UTA_TestMethodExpectedParameters" xml:space="preserve">
    <value>Solo los métodos de pruebas controladas por datos pueden tener parámetros. ¿Quería usar [DataRow] o [DynamicData]?</value>
  </data>
  <data name="AttachmentSetDisplayName" xml:space="preserve">
    <value>MSTestAdapterV2</value>
  </data>
  <data name="CouldNotInspectTypeDuringDiscovery" xml:space="preserve">
    <value>MSTestAdapter no detectó pruebas en la clase '{0}' del ensamblado '{1}' porque {2}.</value>
  </data>
  <data name="UTA_TestContextSetError" xml:space="preserve">
    <value>No se puede establecer la propiedad TestContext para la clase {0}. Error: {1}.</value>
  </data>
  <data name="UTA_ErrorMultiAssemblyClean" xml:space="preserve">
    <value>UTA014: {0}: No se puede definir más de un método con el atributo AssemblyCleanup dentro de un ensamblado.</value>
  </data>
  <data name="UTA_FailedToGetTestMethodException" xml:space="preserve">
    <value>No se pudo obtener la excepción iniciada por el método de prueba {0}.{1}.</value>
  </data>
  <data name="InvalidParallelWorkersValue" xml:space="preserve">
    <value>Valor no válido "{0}" especificado para "Trabajadores". El valor debe ser un entero no negativo.</value>
  </data>
  <data name="UTA_EndOfInnerExceptionTrace" xml:space="preserve">
    <value>--- Fin del seguimiento de la pila de excepción interna ---</value>
  </data>
  <data name="UTA_ErrorInvalidTimeout" xml:space="preserve">
    <value>UTA054: atributo tiempo espera {0}.{1} no válido. Valor tiempo de espera debe ser entero válido y no menor que 0.</value>
  </data>
  <data name="LegacyScenariosNotSupportedWarning" xml:space="preserve">
    <value>Advertencia: No se admite un archivo testsettings o vsmdi con el adaptador de MSTest V2.</value>
  </data>
  <data name="Common_MustBeGreaterThanZero" xml:space="preserve">
    <value>El parámetro debe ser mayor que cero.</value>
  </data>
  <data name="UTA_NoDefaultConstructor" xml:space="preserve">
    <value>No se puede obtener el constructor predeterminado para la clase {0}.</value>
  </data>
  <data name="UTA_TestContextLoadError" xml:space="preserve">
    <value>No se puede encontrar la propiedad {0}.TestContext. Error:{1}.</value>
  </data>
  <data name="EnumeratorLoadTypeErrorFormat" xml:space="preserve">
    <value>{0}: {1}</value>
  </data>
  <data name="UTA_MultipleExpectedExceptionsOnTestMethod" xml:space="preserve">
    <value>El método de prueba {0}.{1} tiene definidos varios atributos derivados de ExpectedExceptionBaseAttribute. Solo se permite uno de estos atributos.</value>
  </data>
  <data name="UTA_ErrorInValidTestContextSignature" xml:space="preserve">
    <value>UTA031: la clase {0} no tiene la propiedad TestContext válida. TestContext debe ser de tipo TestContext, debe ser no estática, pública y no debe ser de solo lectura. Por ejemplo: public TestContext TestContext.</value>
  </data>
  <data name="UTA_CleanupMethodThrowsGeneralError" xml:space="preserve">
    <value>Error al llamar al método Test Cleanup para la clase de prueba {0}: {1}</value>
  </data>
  <data name="UTA_MethodDoesNotExists" xml:space="preserve">
    <value>El método {0}.{1} no existe.</value>
  </data>
  <data name="TestAssembly_FileDoesNotExist" xml:space="preserve">
    <value>El archivo no existe: {0}</value>
  </data>
  <data name="UTA_CleanupStackTrace" xml:space="preserve">
    <value>Seguimiento de pila de TestCleanup</value>
  </data>
  <data name="UTA_TypeLoadError" xml:space="preserve">
    <value>No se puede obtener el tipo {0}. Error: {1}.</value>
  </data>
  <data name="TypeLoadFailed" xml:space="preserve">
    <value>No se pueden cargar tipos del origen de prueba "{0}". Puede que no se detecten algunas o ninguna de las pruebas de este origen.
Error: {1}</value>
  </data>
  <data name="UTA_ErrorMultiClassClean" xml:space="preserve">
    <value>UTA026: {0}: No se puede definir más de un método con el atributo ClassCleanup dentro de una clase.</value>
  </data>
</root>